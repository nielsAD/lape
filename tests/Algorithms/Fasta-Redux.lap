{ The Computer Language Benchmarks Game

  http://shootout.alioth.debian.org

  contributed by Ian Osgood

  modified by Vincent Snijders

  modified by Steve Fisher

  modified by Caleb Hattingh

  modified to compile with Lape
}

const
  ALU : AnsiString =
  'GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG' +
  'GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA' +
  'CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT' +
  'ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA' +
  'GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG' +
  'AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC' +
  'AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA';

  codes = 'acgtBDHKMNRSVWY';

  IUB : array[0..14] of double = [0.27, 0.12, 0.12, 0.27, 0.02, 0.02, 0.02,
    0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02];

  HomoSap : array[0..3] of double = [0.3029549426680, 0.1979883004921,
    0.1975473066391, 0.3015094502008];

  //  Width of ouput lines.

  width = 60;
  LOOKUP_SIZE = 4096;
  LOOKUP_SCALE = LOOKUP_SIZE - 1;

type
  TGene = record
    prob: double;
    code: char;
    cprob_lookup: double;
  end;
  PGene = ^TGene;

var
  n : longint;
  Genes: array of TGene;
  text_buf: array[0..$ffff] of byte;
  Gene_Lookup: array[0..LOOKUP_SCALE] of PGene;

procedure fasta_repeat( n: integer );
var
  source_alu: ansistring;
  here: integer;
begin
  source_alu := alu + Copy(alu, 1, width - 1);
  here := 1;
  repeat
    writeln( Copy(source_alu, here, width) );
    Inc(here, width);
    if here > length( alu ) then
      Dec(here, length( alu ));
    Dec(n, width);
  until n <= width;
  writeln( Copy(source_alu, here, n) );
end;

var
  seed : integer = 42;
function gen_random(limit : integer): double;
const
  IM = 139968;
  IA = 3877;
  IC = 29573;
begin
  seed := (seed * IA + IC) mod IM;
  result := limit * seed * (1 / IM);
end;

procedure init_genes(const probs: array of double);
var
  i, j : integer;
  sum_prob: double;
begin
  setLength(Genes, length(probs));
  sum_prob := 0.0;
  for i := 0 to high(probs) do
  begin
    sum_prob := sum_prob + probs[i];
    Genes[i].prob := sum_prob;
    Genes[i].code := codes[i+1];
    Genes[i].cprob_lookup := sum_prob * LOOKUP_SCALE;
  end;
  j := 0;
  for i := 0 to LOOKUP_SIZE - 1 do
  begin
    while Genes[j].cprob_lookup < i do
      inc(j);
    Gene_Lookup[i] := @Genes[j];
  end;
end;

procedure fasta_random(n : integer; const probs: array of double);

  function choose_code : char;
  var r : double;
      gene: PGene;
  begin
    r := gen_random(1);
    gene := Gene_Lookup[Trunc(r * LOOKUP_SCALE)];
    while r >= gene^.prob do
      inc(gene);
   result := gene^.code;
  end;

  procedure do_one_line( size: integer );
  var
    line : string;
    p, p_limit : pchar;
  begin
    SetLength(line, size);
    p := @line[1];
    p_limit := @line[size];
    while p <= p_limit do
    begin
      p^ := choose_code;
      inc(p);
    end;
    writeln( line );
  end;

begin
  // Make gene array.

  init_genes(probs);

  while n > width do
  begin
    do_one_line( width );
    Dec(n, width);
  end;

  do_one_line( n );
end;


begin
  n := 1000;

  writeln('>ONE Homo sapiens alu');
  fasta_repeat(n*2);

  writeln('>TWO IUB ambiguity codes');
  fasta_random(n*3, IUB);

  writeln('>THREE Homo sapiens frequency');
  fasta_random(n*5, HomoSap);
end.